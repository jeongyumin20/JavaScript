/*
// 다른 회사들과 표준 규약을 만들어 정의하기 위해 
1. JavaScript : ES6(ECMA Script 6) // es5는 없나요, ECMA는 뭔가요, 차이는 뭔가요
1) Basic(문법) -  let, const
                  function, class, iterator, ..
2) Advance(내부구현) - Scope, Hoisting, Closer, Prototype.. ( global , local 차이 스코프 체이닝 어떻게 하는지)

2. Scope란?
- 식별자 ( 변수, 함수, 클래스.. 참조하는 범위 )의 유효한 범위 ﹒ 영역
- 변수를 참조할 수 있는 유효한 범위 ﹒ 영역

스코프 정의 - { }(블럭) 단위로 정의됨
블럭 :  블럭({}}, 함수(function(){}), 제어문(for {}, if {})

**
블럭 내부에서 블럭 외부의 변수를 참조 가능
블럭 외부에서 블럭 내부의 변수는 참조 불가능

블럭을 이용하여 식별자의 Scope를 정의
-> 이름 충돌 방지, 메모리 절약 (효율성)

**
식별자 (변수)는 최대한 필요한 블럭에서 정의해서 사용하도록 한다
코딩 컨벤션 식별자 선언은 기능에 따라서 최대한 블럭 안에서 정의하도록 한다 

function test {} : test 함수 블럭  
class test {} : test 클래스 블럭  


scope.js
---------------------
const a = 200;  // 글로벌(전역) 변수 정의 : 현재 scope.js 파일 끝날 때까지 살아있다. 범위는 메모리에 살아있는 기준 ( 메모리에 있어야 참조 되니까 , scope.js 실행되면 엔진이 이 a를 메모리에 가장 먼저 넣고 오래 살아있다 파일이 끝나야만 메모리에서 삭제되니까 )
{ 
  const a = 100;  // 로컬(멤버) 변수 정의  : 블락 안에서 누군가가 참조 했을 거고 블럭 빠져나오면 밖에서 참조 안된다
  // 가비지 컬렉터가 삭제를 해준다  : 가비지 컬렉터는 어떻게 만들어지고 무슨 일을 수행하는지
  console.log(a)  // 100  가장 근거리에 있는 해당 변수를 찾는다
}
console.log(a)  // 200 두번째 큰 넓이의 스코프를 기준으로 찾는다 

자바스크립트는 스코프 별로 정의된 정보를 저장하는 객체 환경들이 있다 : 렉시컬 환경
이 객체들의 체이닝을 이용해서 검색을 하는 것 ( 그래서 지역변수 100 예제 보면 이 안에서 정의된 변수를 먼저 찾아주는 것 )


3. 가비지 컬렉터(Gabage Collector)
* C언어 - 개발자가 메모리 선언, 할당, 데이터처리, 메모리 반환(삭제)
* JAVA, C#, JS - 메모리 관리 해주는 GC(Gabage Collector를 가지고 있다

// c언어 개발자가 데이터 처리만 생각해서 나온거 생각하고 삭제 안하면 메모리 반환이 되지 않아 부족해서 스택오버플로어나 어플리케이션이 중단하거나 블루스크린뜨는 상황 발생

발전: 객체 지향언어는 jvm을 활용하여 데이터처리까지 하고 가비지컬렉터가 메모리 삭제하는 부분을 맡는 것
C#은 자바 거의 흡사하게 따라 만든 것 ( 90프로 이상? )

4. 실행 컨텍스트 (Execution Context)
- 실행 순서와 스코프를 기억하고 있다 ( 실행순서 : 콜스택에 쌓인다 )
- 실행 컨텍스트는 스코프 정보를 가지고 있는 (Lexical Environment Object)
  렉시컬 환경 오브젝트를 생성하여 관리하며 
  렉시컬 환경 오브젝트는 각각의 스코프 체이닝으로 연결됨
- 코드 맨 안쪽의 블럭이 맨 먼저 생성됨

*/

// [스코프란?]
/* 
식별자(변수, 함수)의 유효한 범위를 의미하며, 블럭 단위로 정의됩니다 
블럭 안에서 정의된 식별자는 블러기 종료되면 GC의 대상이 됩니다   
스코프 외부에서 스코프 내부의 식별자는 참조가 불가능하지만 내부에서 외부 스코프의 식별자는 참조가 가능합니다

참조가 가능한 이유는
실행 컨텍스트에 있는 렉시컬 환경 오브젝트가 스코프 단위로 정보를 기억하고 있으며 
맨 안쪽에 생성되는 스코프부터 체이닝을 이용하여 연결되어 있기 때문입니다

이렇게 생성된 LEO를 통해 스코프의 참조가 가능해집니다

즉, 스코프를 사용할 때 메모리 절약과 성능을 고려한다면
식별자 선언과 사용은 필요한 블럭에서 정의하고 호출하도록 하는 것이 좋다고 생각합니다
*/

// {} 블럭 단위로 나뉘어진 식별자로
// 실행 컨텍스트에 렉시컬 환경 오브젝트로 안쪽 스코프부터 생성 관리되며 생성된 오브젝트는 체이닝으로 스코프 연결이 되어 한방향으로 안쪽에서 위로 참조가 가능하다
// 해당 블럭 스코프 영역의 기준으로 블럭이 끝나면 가비지 컬렉터 대상이 된다 ( 함수는 호출이 끝난 뒤 대상 )

/* 
Hoisting, Closure, Prototype 정의


5. 호이스팅(hoisting)
es6 나오기 이전에도 존재했지만 조금 달라져서 어떻게 코딩을 해야할까가 중점!
개념 접근시 원본 단어로 정리하는 것이 좋다 

- 자바스크립트 엔진(인터프리터)이 실행하기 전에(런타임) 변수﹒함수﹒클래스 등을 최상단으로 끌어올리는 작업
( 아래 변수나 함수 선언하고 호출 위에 있어도 에러 없이 작동하는 이유 )

- ES6 이전에는 변수 ﹒클래스는 호이스팅 작업시 선언과 초기화가 함께 진행되었으나, ES6부터는 선언만 가능해짐
( 디폴트 값을 주지 못한다 : 데이터 타입이 명시적으로 선언되어 있지 않기 때문에 )

let String name = 'hong'; 이렇게 데이터 타입이 명시적 선언이 되면 가능하지만
let name = 'hong'; 데이터 타입에 따라 변수의 데이터 타입이 바뀌기 때문에 자바스크립트에서는 선언만 가능

- ES6 기준으로 let﹒const 키워드 등장 
- var 사용은 되도록 지양, let﹒const 권장 사용시 가독성이 좋고 명확한 프로그래밍 가능 

*/

/* 
6. var 특징
- 다른 언어와 코딩 방식(변수 할당 등)의 차이로 디버깅이 어려움 ( 다른 언어는 정수 실수 문자 등 타입 알려달라고 한다 )
- 코드의 가독성과 유지보수 측면에서 좋지 않음 
  1)  변수 선언시 키워드가 없어도 사용 가능하므로, 선언인지 재할당인지 구분이 어려움
      name = '홍길동'; 선언인지 아래에서 값을 바꾸는 것인지 이것만 보면 판단이 어렵다 
          -> var name = '홍길동';
  
  2) 중복 선언이 가능 
  var person = '홍길동';
  var person = '홍길순';  
  console.log(person); // 홍길순 인터프리터 방식으로 가장 마지막 선언의 데이터가 들어간다

  3) 변수﹒ 클래스는 블럭 단위 스코프가 안 됨 // 로컬변수인지 글로벌 변수인지 구분이 불가능
  var fruit = 'apple'; // 전역
  { // var 키워드는 {} 의 의미가 없다
   var fruit = 'orange'; // 로컬 ?
   console.log(fruit); // orange
  }
  console.log(fruit); // orange

  4) 함수 레벨 스코프는 블럭 단위 스코프 지원 된다
*/

/* 
7. 프로토타입(Prototype)
1. NOUM an original or first model of something from which other forms are copied or developed
2. NOUM someone or something that has the typical qualities of a particular group, kind, etc.
3. NOUM a first or early example that is used as a model for what comes later


- 자바스크립트에서 객체지향적으로 프로그래밍을 하기 위해 
  프로토타입(자바면 클래스의 한 종류인 인터페이스)이 제공되며, 공통적인 특징, 기능, 상태 등을 저장하여 
  필요한 객체에게 상속을 통해 적용할 수 있다  : 탕후루 같이 코팅으로 감쳐줌

- 최상위 프로토타입(클래스 : 프로토타입 클래스라고도 한다)은 Object로 생성되는 모든 객체는 
  상속을 받아 구현된다 


strArr = new Array(); 
strArr = [];  // new Array(); 
// 클래스인 Array를 찾아서 만들어주고 이걸 [] 이렇게 써도 같은 의미로 동작하니 이렇게 많이 사용한다 
// 우리가 만든 클래스가 아니라 자바스크립트에서 제공하는 빌트인 객체 // 클래스를 자바스크립트에게 달라해서 array 타입으로 만들고 이걸 strArray가 그 주소를 레퍼런스 
// 그때 만들어지는 Array 우리가 만들지 않는 자바스크립트 빌트인 객체로 안에 뭐가 들어있는지 알 수 없다 
// 우리가 class Array {} 이렇게 만들지 않았는데 만들어진것이니 자바스크립트에 있는 걸로 만들어진 것
// 우리가 만들었으면 {} 이 안에 적으니 알지만 우리가 만들지 않았으니 모르니 msdn보는 거고 그 안에 뭐들었는지 설명해주는게 api


class Person = {
  constructor() {
    this.name = 'hong';
    this.age = 20;
  }
}

let hong = new Person(); // 생성자 호출 : 변수하나 만들어지는데 new Person 이니까 메모리 힙에 만든다
// new 붙으면 메모리 힙에 만들어진다 Person 클래스 만들러 갔더니 
*/

/* 
8. 클로저 (Closure)
- 함수에서 사용되는 중첩 함수 정의로 생성되는 블럭 스코프를 
  통해 내부의 함수 스코프에서 외부의 함수 스코프에 접근 가능하도록 허용하는 것을 의미함
  
  function outer() {
    const a = 1;
    function inner() {
      console.log(a);
    }
    inner();
  }
  outer();
  // 이 외부환경에서 inner() 호출 불가능하므로 inner() 폐쇄적 환경 
*/
